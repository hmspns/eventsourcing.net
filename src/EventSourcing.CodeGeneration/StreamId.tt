<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cs" encoding="utf-8" #>
<#@ import namespace="System.IO" #>
<#@ include file="IdentitiesConfigParser.ttinclude" once="true"#>
<#@ include file="SaveHelpers.ttinclude" once="true"#>
<#@ include file="BuildIntBased.ttinclude" once="true"#>

<#
    JsonData data = this.ReadConfig();
    DataItem item = new DataItem()
    {
        Name = "StreamId",
        Comment = "Identifier of stream",
        Prefix = "event-stream",
        IsPartial = false
    };
#>
// <auto-generated />
using System;
using EventSourcing.Net.Abstractions.Contracts;

namespace EventSourcing.Net.Abstractions.Identities
{
    /// <summary>
    /// <#= item.Comment #>.
    /// </summary>
    /// <remarks>Generated from EventSourcing.CodeGeneration.Identities.tt</remarks>
    public <#= item.IsPartial ? "partial" : "readonly" #> struct <#= item.Name #> : IIdentity, IEquatable<<#= item.Name #>>
    {
        private readonly string _id;

        /// <summary>
        /// Get the prefix.
        /// </summary>
        public static readonly <#= item.Name #> Empty = new <#= item.Name #>();

        /// <summary>
        /// Get empty <#= item.Name #>.
        /// </summary>
        public static <#= item.Name #> New(string id)
        {
            return new <#= item.Name #>(id);
        }

        /// <summary>
        /// Create <#= item.Name #> with string value.
        /// </summary>
        public <#= item.Name #>(string id)
        {
            if (id == null)
            {
                throw new ArgumentNullException(nameof(id));
            }

            _id = id;
        }

        /// <summary>
        /// Parse from string.
        /// </summary>
        /// <param name="serializedId">String value.</param>
        /// <returns><#= item.Comment #>.</returns>
        /// <exception cref="ArgumentNullException">String is null.</exception>
        public static <#= item.Name #> Parse(string serializedId)
        {
            if (serializedId == null)
            {
                throw new ArgumentNullException(nameof(serializedId));
            }

            return new <#= item.Name #>(serializedId);
        }

        /// <summary>
        /// Parse from string without throwing exception.
        /// </summary>
        /// <param name="serializedId">String value.</param>
        /// <param name="id">Parsed <#= item.Name #>.</param>
        /// <returns>True if parsed successfully, otherwise false.</returns>
        public static bool TryParse(string serializedId, out <#= item.Name #> id)
        {
            if (!string.IsNullOrWhiteSpace(serializedId))
            {
                id = <#= item.Name #>.Parse(serializedId);
                return true;
            }

            id = default(<#= item.Name #>);
            return false;
        }

        /// <summary>
        /// Get internal id.
        /// </summary>
        public string Id => _id;

        public override string ToString()
        {
            return _id;
        }

        public bool Equals(<#= item.Name #> other) { return _id == other._id; }

        public override bool Equals(object other)
        {
            if ((other == null) || !(other is <#= item.Name #>)) return false;

            return this.Equals((<#= item.Name #>)other);
        }

        public override int GetHashCode() { return _id.GetHashCode(); }

        public static bool operator ==(<#= item.Name #> a, <#= item.Name #> b) { return a._id == b._id; }
        public static bool operator !=(<#= item.Name #> a, <#= item.Name #> b) { return a._id != b._id; }

#region Parsing overloads
        public static StreamId FromIdentity(IIdentity identity)
        {
            return StreamId.Parse(identity.ToString());
        }
<#
    foreach (var dataItem in data.All)
    {
#>

        public static <#= item.Name #> FromIdentity(<#= dataItem.Name #> identity)
        {
            return <#= item.Name #>.Parse(identity.ToString());
        }
<#
    }
#>
#endregion
    }
}
<#
    SaveFile("Identities", item.Name, this.GenerationEnvironment.ToString());
    this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
#>