<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cs" encoding="utf-8" #>
<#@ import namespace="System.IO" #>
<#@ include file="IdentitiesConfigParser.ttinclude" once="true"#>
<#@ include file="SaveHelpers.ttinclude" once="true"#>
<#@ include file="BuildIntBased.ttinclude" once="true"#>

<#@ import namespace="System.Linq" #>
<#
JsonData data = this.ReadConfig();

WriteIntBased(data.IntBased);

foreach (DataItem item in data.GuidBased)
{
#>
// <auto-generated />
using System;
using EventSourcing.Abstractions.Contracts;

namespace EventSourcing.Abstractions.Identities
{
    /// <summary>
    /// <#=item.Comment#>.
    /// </summary>
    /// <remarks>Generated from EventSourcing.CodeGeneration.Identities.tt</remarks>
    public <#=item.IsPartial ? "readonly partial" : "readonly"#> struct <#=item.Name#> : IIdentity, IEquatable<<#=item.Name#>>
    {
        private readonly Guid _id;

        /// <summary>
        /// Get the prefix.
        /// </summary>
        public static readonly string Prefix = "<#=item.Prefix#>_";

        /// <summary>
        /// Get empty <#=item.Name#>.
        /// </summary>
        public static readonly <#=item.Name#> Empty = new <#=item.Name#>(Guid.Empty);

        /// <summary>
        /// Create <#=item.Name#> with random value.
        /// </summary>
        public static <#=item.Name#> New()
        {
            return new <#=item.Name#>(Guid.NewGuid());
        }

        /// <summary>
        /// Initiate new object.
        /// </summary>
        public <#=item.Name#>(Guid id)
        {
            _id = id;
        }

        /// <summary>
        /// Parse from string.
        /// </summary>
        /// <param name="serializedId">String value.</param>
        /// <returns><#=item.Comment#>.</returns>
        /// <exception cref="ArgumentException">String cannot be parsed to <#=item.Name#>.</exception>
        public static <#=item.Name#> Parse(string serializedId)
        {
            if (!serializedId.StartsWith(Prefix, StringComparison.Ordinal))
            {
                throw new ArgumentException("Invalid <#=item.Name#>", "serializedId");
            }

            ReadOnlySpan<char> span = serializedId.AsSpan();
            Guid id = Guid.Parse(span.Slice(Prefix.Length));

            return new <#=item.Name#>(id);
        }

        /// <summary>
        /// Parse from string without throwing exception.
        /// </summary>
        /// <param name="serializedId">String value.</param>
        /// <param name="id">Parsed <#=item.Name#>.</param>
        /// <returns>True if parsed successfully, otherwise false.</returns>
        public static bool TryParse(string serializedId, out <#=item.Name#> id)
        {
            Guid guid;

            if (!string.IsNullOrWhiteSpace(serializedId) && serializedId.StartsWith(Prefix, StringComparison.Ordinal))
            {
                ReadOnlySpan<char> span = serializedId.AsSpan().Slice(Prefix.Length);
                if (Guid.TryParse(span, out guid))
                {
                    id = new <#=item.Name#>(guid);
                    return true;
                }
            }

            id = default(<#=item.Name#>);
            return false;
        }

        /// <summary>
        /// Get internal id.
        /// </summary>
        public Guid Id => _id;

        public static implicit operator Guid(<#=item.Name#> id)
        {
            return id._id;
        }

        public static implicit operator <#=item.Name#>(Guid id)
        {
            return new <#=item.Name#>(id);
        }

        public override string ToString()
        {
            return string.Concat(Prefix, _id.ToString());
        }

        public bool Equals(<#=item.Name#> other) { return _id == other._id; }

        public override bool Equals(object other)
        {
            if ((other == null) || !(other is <#=item.Name#>)) 
            {
                return false;
            }

            return this.Equals((<#=item.Name#>)other);
        }

        public override int GetHashCode() { return _id.GetHashCode(); }

        public static bool operator ==(<#=item.Name#> a, <#=item.Name#> b) { return a._id == b._id; }
        public static bool operator !=(<#=item.Name#> a, <#=item.Name#> b) { return a._id != b._id; }
    }
}
<#
    SaveFile("Identities", item.Name, this.GenerationEnvironment.ToString());
    this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
}

foreach (DataItem item in data.StringBased)
{
#>
// <auto-generated />
using System;
using EventSourcing.Abstractions.Contracts;

namespace EventSourcing.Abstractions.Identities
{
    /// <summary>
    /// <#=item.Comment#>.
    /// </summary>
    /// <remarks>Generated from EventSourcing.CodeGeneration.Identities.tt</remarks>
    public <#=item.IsPartial ? "readonly partial" : "readonly"#> struct <#=item.Name#> : IIdentity, IEquatable<<#=item.Name#>>
    {
        private readonly string _id;

        /// <summary>
        /// Get the prefix.
        /// </summary>
        public static readonly string Prefix = "<#=item.Prefix#>_";

        /// <summary>
        /// Get empty <#=item.Name#>.
        /// </summary>
        public static readonly <#=item.Name#> Empty = new <#=item.Name#>();

        /// <summary>
        /// Create <#=item.Name#> with string value.
        /// </summary>
        public static <#=item.Name#> New(string id)
        {
            return new <#=item.Name#>(id);
        }

        /// <summary>
        /// Initiate new object.
        /// </summary>
        public <#=item.Name#>(string id)
        {
            if (id == null)
            {
                throw new ArgumentNullException(nameof(id));
            }

            _id = id;
        }

        /// <summary>
        /// Parse from string.
        /// </summary>
        /// <param name="serializedId">String value.</param>
        /// <returns><#=item.Comment#>.</returns>
        /// <exception cref="ArgumentException">String cannot be parsed to <#=item.Name#>.</exception>
        public static <#=item.Name#> Parse(string serializedId)
        {
            if (serializedId == null)
            {
                throw new ArgumentNullException(nameof(serializedId));
            }

            if (!serializedId.StartsWith(Prefix, StringComparison.Ordinal))
            {
                throw new ArgumentException("Invalid <#=item.Name#>", "serializedId");
            }

            return new <#=item.Name#>(serializedId.Substring(Prefix.Length));
        }

        /// <summary>
        /// Parse from string without throwing exception.
        /// </summary>
        /// <param name="serializedId">String value.</param>
        /// <param name="id">Parsed <#=item.Comment#>.</param>
        /// <returns>True if parsed successfully, otherwise false.</returns>
        public static bool TryParse(string serializedId, out <#=item.Name#> id)
        {
            if (!string.IsNullOrWhiteSpace(serializedId) && serializedId.StartsWith(Prefix, StringComparison.Ordinal))
            {
                id = <#=item.Name#>.Parse(serializedId);
                return true;
            }

            id = default(<#=item.Name#>);
            return false;
        }

        /// <summary>
        /// Get internal id.
        /// </summary>
        public string Id => _id;

        public override string ToString()
        {
            return Prefix + _id;
        }

        public bool Equals(<#=item.Name#> other) { return string.Equals(_id, other._id, StringComparison.Ordinal); }

        public override bool Equals(object other)
        {
            if ((other == null) || !(other is <#=item.Name#>)) return false;

            return this.Equals((<#=item.Name#>)other);
        }

        public override int GetHashCode() { return _id.GetHashCode(); }

        public static bool operator ==(<#=item.Name#> a, <#=item.Name#> b) { return string.Equals(a._id, b._id, StringComparison.Ordinal); }
        public static bool operator !=(<#=item.Name#> a, <#=item.Name#> b) { return !string.Equals(a._id, b._id, StringComparison.Ordinal); }
    }
}
<#
    SaveFile("Identities", item.Name, this.GenerationEnvironment.ToString());
    this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
}
#>
// <auto-generated />
using System;
using EventSourcing.Abstractions.Identities;

namespace EventSourcing.Abstractions.Contracts
{
    /// <summary>
    /// Generic interface for all identities.
    /// </summary>
    public interface IIdentity
    {
        /// <summary>
        /// Parse from string.
        /// </summary>
        /// <param name="raw">Prefixed string.</param>
        /// <returns>Identity with correct type.</returns>
        /// <exception cref="ArgumentNullException">Passed null value.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Prefix couldn't be found.</exception>
        static IIdentity Parse(string raw)
        {
            IIdentity result = raw switch
            {
                null => throw new ArgumentNullException(nameof(raw)),
<#
foreach (var item in data.All)
{
#>
                var s when s.StartsWith("<#=item.Prefix#>_", StringComparison.Ordinal) => <#=item.Name#>.Parse(raw),
<#
}
#>
                _ => throw new ArgumentOutOfRangeException(nameof(raw), raw, "Raw is null")
            };
            return result;
        }

        /// <summary>
        /// Parse from string.
        /// </summary>
        /// <param name="raw">Prefixed string.</param>
        /// <param name="identity">Parsed identity with the correct type.</param>
        /// <returns>True if parsed successfully, otherwise false.</returns>
        /// <exception cref="ArgumentNullException">Passed null value.</exception>
        static bool TryParse(string raw, out IIdentity identity)
        {
            try
            {
                identity = raw switch
                {
                    null => throw new ArgumentNullException(nameof(raw)),
<#
foreach (var item in data.All)
{
#>
                    var s when s.StartsWith("<#=item.Prefix#>_") => <#=item.Name#>.Parse(raw),
<#
}
#>
                    _ => default
                };
                if (identity != default)
                {
                    return true;
                }
            }
            catch
            {
                identity = default;
            }

            return false;
        }

        /// <summary>
        /// Get identity from stream id.
        /// </summary>
        /// <param name="streamId">Stream id.</param>
        /// <returns>Type identity.</returns>
        static IIdentity FromStreamId(StreamId streamId)
        {
            return IIdentity.Parse(streamId.ToString());
        }
    }
}
<#
SaveFile("Contracts", "IIdentity", this.GenerationEnvironment.ToString());
this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
#>